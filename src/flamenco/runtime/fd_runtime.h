#ifndef HEADER_fd_src_flamenco_runtime_fd_runtime_h
#define HEADER_fd_src_flamenco_runtime_fd_runtime_h

#include "stdarg.h"

#include "fd_runtime_err.h"
#include "fd_runtime_init.h"
#include "fd_rocksdb.h"
#include "fd_acc_mgr.h"
#include "fd_hashes.h"
#include "../features/fd_features.h"
#include "context/fd_capture_ctx.h"
#include "context/fd_exec_txn_ctx.h"
#include "info/fd_instr_info.h"
#include "../../disco/pack/fd_microblock.h"
#include "../../ballet/sbpf/fd_sbpf_loader.h"
#include "../vm/fd_vm_base.h"

#include "program/fd_bpf_loader_program.h"

/* Various constant values used by the runtime. */

#define MICRO_LAMPORTS_PER_LAMPORT (1000000UL)

#define DEFAULT_HASHES_PER_TICK  (12500)
#define UPDATED_HASHES_PER_TICK2 (17500)
#define UPDATED_HASHES_PER_TICK3 (27500)
#define UPDATED_HASHES_PER_TICK4 (47500)
#define UPDATED_HASHES_PER_TICK5 (57500)
#define UPDATED_HASHES_PER_TICK6 (62500)

#define FD_RUNTIME_TRACE_NONE   (0)
#define FD_RUNTIME_TRACE_SAVE   (1)
#define FD_RUNTIME_TRACE_REPLAY (2)

#define FD_RUNTIME_OFFLINE_NUM_ROOT_BLOCKS (6UL) /* 6 root blocks for offline replay */

#define FD_RENT_EXEMPT_RENT_EPOCH (ULONG_MAX)

#define SECONDS_PER_YEAR ((double)(365.242199 * 24.0 * 60.0 * 60.0))

/*
 * fd_block_entry_batch_t is a microblock/entry batch within a block.
 * The offset is relative to the start of the block's data region,
 * and indicates where the batch ends.  The (exclusive) end offset of
 * batch i is the (inclusive) start offset of batch i+1.  The 0th batch
 * always starts at offset 0.
 * On the wire, the presence of one of the COMPLETE flags in a data
 * shred marks the end of a batch.
 * In other words, batch ends are aligned with shred ends, and batch
 * starts are aligned with shred starts.  Usually a batch comprises
 * multiple shreds, and a block comprises multiple batches.
 * This information is useful because bincode deserialization needs to
 * be performed on a per-batch basis.  Precisely a single array of
 * microblocks/entries is expected to be deserialized from a batch.
 * Trailing bytes in each batch are ignored by default.
 */
struct fd_block_entry_batch {
  ulong end_off; /* exclusive */
};
typedef struct fd_block_entry_batch fd_block_entry_batch_t;

/* The below logic is used to size out the memory footprint generated by the
   runtime during transaction execution. */

/* The prevailing layout we have in the runtime is the meta followed by
   the account's data. This struct encodes that layout and asserts that
   the alignment requirements of the constituents are satisfied. */
// TODO: Use this struct at allocation sites so it's clear we use this layout
struct __attribute__((packed)) fd_account_rec {
  fd_account_meta_t meta;
  uchar data[] __attribute__((aligned(8)));
};
typedef struct fd_account_rec fd_account_rec_t;
#define FD_ACCOUNT_REC_ALIGN      (8UL)
#define FD_ACCOUNT_REC_DATA_ALIGN (8UL)
FD_STATIC_ASSERT( FD_ACCOUNT_REC_ALIGN>=alignof(fd_account_meta_t), account_rec_meta_align );
FD_STATIC_ASSERT( FD_ACCOUNT_REC_ALIGN>=FD_ACCOUNT_REC_DATA_ALIGN,  account_rec_data_align );
FD_STATIC_ASSERT( (offsetof(fd_account_rec_t, meta)%alignof(fd_account_meta_t))==0, account_rec_meta_offset );
FD_STATIC_ASSERT( (offsetof(fd_account_rec_t, data)%FD_ACCOUNT_REC_DATA_ALIGN )==0, account_rec_data_offset );

#define MAX_PERMITTED_DATA_INCREASE (10240UL) // 10KB
#define FD_BPF_ALIGN_OF_U128        (8UL    )
FD_STATIC_ASSERT( FD_BPF_ALIGN_OF_U128==FD_ACCOUNT_REC_DATA_ALIGN, input_data_align );
/* https://github.com/anza-xyz/sbpf/blob/v0.12.2/src/ebpf.rs#L37-L38 */
#define FD_RUNTIME_EBPF_HOST_ALIGN (16UL)

/******** These macros bound out memory footprint ********/

/* The tight upper bound on borrowed account footprint over the
   execution of a single transaction. */
#define FD_RUNTIME_BORROWED_ACCOUNT_FOOTPRINT (MAX_TX_ACCOUNT_LOCKS * FD_ULONG_ALIGN_UP( FD_ACC_TOT_SZ_MAX, FD_ACCOUNT_REC_ALIGN ))

/* The bpf loader's serialization footprint is bounded in the worst case
   by 64 unique writable accounts which are each 10MiB in size (bounded
   by the amount of transaction accounts).  We can also have up to
   FD_INSTR_ACCT_MAX (256) referenced accounts in an instruction.

   - 8 bytes for the account count
   For each account:
     If duplicated:
       - 8 bytes for each duplicated account
    If not duplicated:
     - header for each unique account (96 bytes)
       - 1 account idx byte
       - 1 is_signer byte
       - 1 is_writable byte
       - 1 executable byte
       - 4 bytes for the original data length
       - 32 bytes for the key
       - 32 bytes for the owner
       - 8 bytes for the lamports
       - 8 bytes for the data length
       - 8 bytes for the rent epoch
     - 10MiB for the data (10485760 bytes)
     - 10240 bytes for resizing the data
     - 0 padding bytes because this is already 8 byte aligned
   - 8 bytes for instruction data length
   - 1232 bytes for the instruction data (TXN_MTU)
   - 32 bytes for the program id

  So the total footprint is:
  8 header bytes +
  192 duplicate accounts (256 instr accounts - 64 unique accounts) * 8 bytes     = 1536      duplicate account bytes +
  64 unique accounts * (96 header bytes + 10485760 bytes + 10240 resizing bytes) = 671750144 unique account bytes +
  8 + 1232 + 32                                                                  = 1272 bytes trailer bytes + program id = 671751416 bytes
  Total footprint: 671752960 bytes

  This is a reasonably tight-ish upper bound on the input region
  footprint for a single instruction at a single stack depth.  In
  reality the footprint would be slightly smaller because the
  instruction data can't be equal to the transaction MTU.
 */
#define FD_BPF_LOADER_UNIQUE_ACCOUNT_FOOTPRINT(direct_mapping)                                                                                              \
                                              (1UL                         /* dup byte          */                                                        + \
                                               sizeof(uchar)               /* is_signer         */                                                        + \
                                               sizeof(uchar)               /* is_writable       */                                                        + \
                                               sizeof(uchar)               /* executable        */                                                        + \
                                               sizeof(uint)                /* original_data_len */                                                        + \
                                               sizeof(fd_pubkey_t)         /* key               */                                                        + \
                                               sizeof(fd_pubkey_t)         /* owner             */                                                        + \
                                               sizeof(ulong)               /* lamports          */                                                        + \
                                               sizeof(ulong)               /* data len          */                                                        + \
                                               (direct_mapping ? FD_BPF_ALIGN_OF_U128 : FD_ULONG_ALIGN_UP( FD_RUNTIME_ACC_SZ_MAX, FD_BPF_ALIGN_OF_U128 )) + \
                                               MAX_PERMITTED_DATA_INCREASE                                                                                + \
                                               sizeof(ulong))              /* rent_epoch        */
#define FD_BPF_LOADER_DUPLICATE_ACCOUNT_FOOTPRINT (8UL) /* 1 dup byte + 7 bytes for padding */

#define FD_BPF_LOADER_INPUT_REGION_FOOTPRINT(account_lock_limit, direct_mapping)                                                                      \
                                              (FD_ULONG_ALIGN_UP( (sizeof(ulong)         /* acct_cnt       */                                       + \
                                                                   account_lock_limit*FD_BPF_LOADER_UNIQUE_ACCOUNT_FOOTPRINT(direct_mapping)        + \
                                                                   (FD_INSTR_ACCT_MAX-account_lock_limit)*FD_BPF_LOADER_DUPLICATE_ACCOUNT_FOOTPRINT + \
                                                                   sizeof(ulong)         /* instr data len */                                       + \
                                                                   FD_TXN_MTU            /* No instr data  */                                       + \
                                                                   sizeof(fd_pubkey_t)), /* program id     */                                          \
                                                                   FD_RUNTIME_EBPF_HOST_ALIGN ))



#define BPF_LOADER_SERIALIZATION_FOOTPRINT (671752960UL)
FD_STATIC_ASSERT( BPF_LOADER_SERIALIZATION_FOOTPRINT==FD_BPF_LOADER_INPUT_REGION_FOOTPRINT(64UL, 0), bpf_loader_serialization_footprint );

/* Bincode alloc footprint over the execution of a single transaction.
   As well as other footprint specific to each native program type.

   N.B. We know that bincode alloc footprint is bounded, because
   whenever we alloc something, we advance our pointer into the binary
   buffer, so eventually we are gonna reach the end of the buffer.
   This buffer is usually backed by and ultimately bounded in size by
   either accounts data or the transaction MTU.

   That being said, it's not obvious what the tight upper bound would
   be for allocations across all possible execution paths of all native
   programs, including possible CPIs from native programs.  The
   footprint estimate here is based on a manual review of our native
   program implementation.  Note that even if the possible paths remain
   steady at the Solana protocol level, the footprint is subject to
   change when we change our implementation.

   ### Native programs
   ALUT (migrated to BPF)
   Loader
     - rodata for bpf program relocation and validation
   Compute budget (0 allocations)
   Config (migrated to BPF)
   Precompile (0 allocations)
   Stake
     - The instruction with the largest footprint is deactivate_delinquent
       - During instruction decode, no allocations
       - During execution, this is (vote account get_state() + vote convert_to_current()) times 2, once for delinquent_vote_account, and once for reference_vote_account
   System
     - system_program_instruction_decode seed
   Vote
     - The instruction with the largest footprint is compact vote state update
       - During instruction decode, this is 9*lockouts_len bytes, MTU bounded
       - During execution, this is vote account get_state() + vote convert_to_current() + 12*lockouts_len bytes + lockouts_len ulong + deq_fd_landed_vote_t_alloc(lockouts_len)
   Zk Elgamal (0 allocations)

   The largest footprint is hence deactivate_delinquent, in which the
   two get_state() calls dominate the footprint.  In particular, the
   authorized_voters treaps bloat 40 bytes (epoch+pubkey) in a vote
   account to 72 bytes (sizeof(fd_vote_authorized_voter_t)) in memory.
 */
#define FD_RUNTIME_BINCODE_AND_NATIVE_FOOTPRINT (2UL*FD_RUNTIME_ACC_SZ_MAX*72UL/40UL)

/* Misc other footprint. */
#define FD_RUNTIME_SYSCALL_TABLE_FOOTPRINT (FD_MAX_INSTRUCTION_STACK_DEPTH*FD_ULONG_ALIGN_UP(FD_SBPF_SYSCALLS_FOOTPRINT, FD_SBPF_SYSCALLS_ALIGN))

#define FD_RUNTIME_VM_TRACE_EVENT_MAX      (128UL<<20)
#define FD_RUNTIME_VM_TRACE_EVENT_DATA_MAX (2048UL)
#define FD_RUNTIME_VM_TRACE_FOOTPRINT      (FD_MAX_INSTRUCTION_STACK_DEPTH*fd_ulong_align_up( fd_vm_trace_footprint( FD_RUNTIME_VM_TRACE_EVENT_MAX, FD_RUNTIME_VM_TRACE_EVENT_DATA_MAX ), fd_vm_trace_align() ))

#define FD_RUNTIME_MISC_FOOTPRINT (FD_RUNTIME_SYSCALL_TABLE_FOOTPRINT)
#define FD_SOLFUZZ_MISC_FOOTPRINT (FD_RUNTIME_SYSCALL_TABLE_FOOTPRINT + FD_RUNTIME_VM_TRACE_FOOTPRINT)

/* Now finally, we bound out the footprint of transaction execution. */
#define FD_RUNTIME_TRANSACTION_EXECUTION_FOOTPRINT(account_lock_limit, direct_mapping)                                         \
                                                  (FD_RUNTIME_BORROWED_ACCOUNT_FOOTPRINT                                     + \
                                                   FD_RUNTIME_INPUT_REGION_TXN_FOOTPRINT(account_lock_limit, direct_mapping) + \
                                                   FD_RUNTIME_BINCODE_AND_NATIVE_FOOTPRINT                                   + \
                                                   FD_RUNTIME_MISC_FOOTPRINT)

/* Convenience macros for common use cases.

   TODO: If account lock limits are increased to 128, this macro will need to be updated. */
#define FD_RUNTIME_TRANSACTION_EXECUTION_FOOTPRINT_FUZZ    FD_RUNTIME_TRANSACTION_EXECUTION_FOOTPRINT(64UL, 0) + FD_SOLFUZZ_MISC_FOOTPRINT
#define FD_RUNTIME_TRANSACTION_EXECUTION_FOOTPRINT_DEFAULT FD_RUNTIME_TRANSACTION_EXECUTION_FOOTPRINT(64UL, 0)

FD_PROTOTYPES_BEGIN

/* Runtime Helpers ************************************************************/

/*
   Returns 0 on success, and non zero otherwise.  On failure, the
   out values will not be modified.
 */
int
fd_runtime_compute_max_tick_height( ulong   ticks_per_slot,
                                    ulong   slot,
                                    ulong * out_max_tick_height /* out */ );

void
fd_runtime_update_leaders( fd_bank_t *          bank,
                           fd_runtime_stack_t * runtime_stack );

/* Block Level Execution Prep/Finalize ****************************************/

#define FD_BLOCK_OK                          (0UL)
#define FD_BLOCK_ERR_INCOMPLETE              (1UL)
#define FD_BLOCK_ERR_INVALID_ENTRY_HASH      (2UL)
#define FD_BLOCK_ERR_INVALID_LAST_TICK       (3UL)
#define FD_BLOCK_ERR_TOO_FEW_TICKS           (4UL)
#define FD_BLOCK_ERR_TOO_MANY_TICKS          (5UL)
#define FD_BLOCK_ERR_INVALID_TICK_HASH_COUNT (6UL)
#define FD_BLOCK_ERR_TRAILING_ENTRY          (7UL)
#define FD_BLOCK_ERR_DUPLICATE_BLOCK         (8UL)

/* Load the accounts in the address lookup tables of txn into out_accts_alt */
int
fd_runtime_load_txn_address_lookup_tables(
    fd_txn_t const *          txn,
    uchar const *             payload,
    fd_funk_t *               funk,
    fd_funk_txn_xid_t const * xid,
    ulong                     slot,
    fd_slot_hash_t const *    hashes, /* deque */
    fd_acct_addr_t *          out_accts_alt
);

int
fd_runtime_block_execute_prepare( fd_bank_t *               bank,
                                  fd_accdb_user_t  *        accdb,
                                  fd_funk_txn_xid_t const * xid,
                                  fd_runtime_stack_t *      runtime_stack,
                                  fd_capture_ctx_t *        capture_ctx );

void
fd_runtime_block_execute_finalize( fd_bank_t *               bank,
                                   fd_accdb_user_t  *        accdb,
                                   fd_funk_txn_xid_t const * xid,
                                   fd_capture_ctx_t *        capture_ctx,
                                   int                       silent );

/* Transaction Level Execution Management *************************************/

int
fd_runtime_pre_execute_check( fd_exec_txn_ctx_t * txn_ctx );

/* fd_runtime_prepare_and_execute_txn is the main entrypoint from the
   executor tile. It is responsible for preparing and executing a single
   transaction. */

int
fd_runtime_prepare_and_execute_txn( fd_banks_t *        banks,
                                    ulong               bank_idx,
                                    fd_exec_txn_ctx_t * txn_ctx,
                                    fd_txn_p_t *        txn,
                                    fd_capture_ctx_t *  capture_ctx,
                                    fd_exec_stack_t *   exec_stack,
                                    uchar *             dumping_mem );

void
fd_runtime_finalize_txn( fd_funk_t *               funk,
                         fd_progcache_t *          progcache,
                         fd_txncache_t *           txncache,
                         fd_funk_txn_xid_t const * xid,
                         fd_exec_txn_ctx_t *       txn_ctx,
                         fd_bank_t *               bank,
                         fd_capture_ctx_t *        capture_ctx );

/* Epoch Boundary *************************************************************/

/* This is roughly Agave's process_new_epoch() which gets called from
   new_from_parent() for every slot.
   https://github.com/anza-xyz/agave/blob/v1.18.26/runtime/src/bank.rs#L1483
   Account changes done by this function are counted towards the first
   slot of the new epoch (NOT the last slot of the old epoch). */
void
fd_runtime_block_pre_execute_process_new_epoch( fd_banks_t *              banks,
                                                fd_bank_t *               bank,
                                                fd_accdb_user_t *         accdb,
                                                fd_funk_txn_xid_t const * xid,
                                                fd_capture_ctx_t *        capture_ctx,
                                                fd_runtime_stack_t *      runtime_stack,
                                                int *                     is_epoch_boundary );

/* Offline Replay *************************************************************/

void
fd_runtime_read_genesis( fd_banks_t *                       banks,
                         fd_bank_t *                        bank,
                         fd_accdb_user_t *                  accdb,
                         fd_funk_txn_xid_t const *          xid,
                         fd_capture_ctx_t *                 capture_ctx,
                         fd_hash_t const *                  genesis_hash,
                         fd_lthash_value_t const *          genesis_lthash,
                         fd_genesis_solana_global_t const * genesis_block,
                         fd_runtime_stack_t *               runtime_stack );


/* Returns whether the specified epoch should use the new vote account
   keyed leader schedule (returns 1) or the old validator identity keyed
   leader schedule (returns 0). See SIMD-0180.
   This is the analogous of Agave's Bank::should_use_vote_keyed_leader_schedule():
   https://github.com/anza-xyz/agave/blob/v2.3.1/runtime/src/bank.rs#L6148 */
int
fd_runtime_should_use_vote_keyed_leader_schedule( fd_bank_t * bank );

FD_PROTOTYPES_END

#endif /* HEADER_fd_src_flamenco_runtime_fd_runtime_h */
